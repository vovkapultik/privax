import { Connection, Keypair, PublicKey, SystemProgram } from '@solana/web3.js';
import { Program, Wallet, AnchorProvider } from '@coral-xyz/anchor';
import { TOKEN_PROGRAM_ID, Token } from '@solana/spl-token';
import * as fs from 'fs';
import * as path from 'path';
import dotenv from 'dotenv';
import BN from 'bn.js';
import { IDL } from './privax_protocol'; // Will be generated by Anchor

dotenv.config();

// Constants and Configuration
const PROGRAM_ID = new PublicKey('Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS');
const RPC_URL = process.env.RPC_URL || 'http://localhost:8899';
const WALLET_PATH = process.env.WALLET_PATH || path.join(process.env.HOME || '', '.config/solana/id.json');

// Helper Functions
function loadWallet(): Keypair {
  const walletData = JSON.parse(fs.readFileSync(WALLET_PATH, 'utf-8'));
  return Keypair.fromSecretKey(new Uint8Array(walletData));
}

function createProvider(): AnchorProvider {
  const wallet = new Wallet(loadWallet());
  const connection = new Connection(RPC_URL, 'confirmed');
  return new AnchorProvider(connection, wallet, { commitment: 'confirmed' });
}

// Main Client Class
class PrivaxClient {
  private program: Program;
  private provider: AnchorProvider;

  constructor() {
    this.provider = createProvider();
    // @ts-ignore - Types will be properly handled when IDL is generated
    this.program = new Program(IDL, PROGRAM_ID, this.provider);
  }

  // Initialize the program with admin configuration
  async initialize(tokenMintAddress: PublicKey, verifierProgramId: PublicKey) {
    const [programStatePDA] = PublicKey.findProgramAddressSync(
      [Buffer.from('program_state')],
      this.program.programId
    );

    console.log('Initializing Privax Protocol...');
    try {
      const tx = await this.program.methods
        .initialize(tokenMintAddress, verifierProgramId)
        .accounts({
          programState: programStatePDA,
          admin: this.provider.wallet.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .rpc();
      
      console.log('Initialization successful!');
      console.log('Transaction signature:', tx);
      return tx;
    } catch (error) {
      console.error('Initialization failed:', error);
      throw error;
    }
  }

  // Add a relayer to the whitelist
  async addRelayer(relayerAddress: PublicKey) {
    const [programStatePDA] = PublicKey.findProgramAddressSync(
      [Buffer.from('program_state')],
      this.program.programId
    );

    console.log(`Adding relayer ${relayerAddress.toBase58()}...`);
    try {
      const tx = await this.program.methods
        .addRelayer(relayerAddress)
        .accounts({
          programState: programStatePDA,
          admin: this.provider.wallet.publicKey,
        })
        .rpc();
      
      console.log('Relayer added successfully!');
      console.log('Transaction signature:', tx);
      return tx;
    } catch (error) {
      console.error('Failed to add relayer:', error);
      throw error;
    }
  }

  // Deposit tokens with a commitment
  async deposit(tokenAccount: PublicKey, amount: number, commitment: Buffer) {
    const [programStatePDA] = PublicKey.findProgramAddressSync(
      [Buffer.from('program_state')],
      this.program.programId
    );

    // Get the token mint from the program state
    const programState = await this.program.account.programState.fetch(programStatePDA);
    const tokenMint = programState.tokenMint;
    
    // Derive the token vault PDA
    const [vaultPDA] = PublicKey.findProgramAddressSync(
      [Buffer.from('program_token_vault'), programStatePDA.toBuffer()],
      this.program.programId
    );
    
    const [vaultAuthority] = PublicKey.findProgramAddressSync(
      [Buffer.from('program_token_vault'), programStatePDA.toBuffer()],
      this.program.programId
    );

    console.log(`Depositing ${amount} tokens...`);
    try {
      const tx = await this.program.methods
        .deposit(new BN(amount), Array.from(commitment))
        .accounts({
          programState: programStatePDA,
          user: this.provider.wallet.publicKey,
          userTokenAccount: tokenAccount,
          programTokenVault: vaultPDA,
          programTokenVaultAuthority: vaultAuthority,
          tokenProgram: TOKEN_PROGRAM_ID,
          systemProgram: SystemProgram.programId,
          rent: await this.provider.connection.getMinimumBalanceForRentExemption(165),
        })
        .rpc();
      
      console.log('Deposit successful!');
      console.log('Transaction signature:', tx);
      return tx;
    } catch (error) {
      console.error('Deposit failed:', error);
      throw error;
    }
  }

  // Example usage (requires implementation of ZK proof generation logic)
  async withdraw(
    proofData: { aProof: Buffer, bProof: Buffer, cProof: Buffer, publicInputs: number[] },
    recipientAddress: PublicKey,
    recipientTokenAccount: PublicKey,
    amountToWithdraw: number
  ) {
    const [programStatePDA] = PublicKey.findProgramAddressSync(
      [Buffer.from('program_state')],
      this.program.programId
    );
    
    // Derive the token vault PDA
    const [vaultPDA] = PublicKey.findProgramAddressSync(
      [Buffer.from('program_token_vault'), programStatePDA.toBuffer()],
      this.program.programId
    );
    
    const [vaultAuthority] = PublicKey.findProgramAddressSync(
      [Buffer.from('program_token_vault'), programStatePDA.toBuffer()],
      this.program.programId
    );

    console.log(`Withdrawing ${amountToWithdraw} tokens to ${recipientAddress.toBase58()}...`);
    try {
      const tx = await this.program.methods
        .withdraw(
          Array.from(proofData.aProof),
          Array.from(proofData.bProof),
          Array.from(proofData.cProof),
          proofData.publicInputs,
          recipientAddress,
          new BN(amountToWithdraw)
        )
        .accounts({
          programState: programStatePDA,
          user: this.provider.wallet.publicKey,
          programTokenVault: vaultPDA,
          programTokenVaultAuthority: vaultAuthority,
          recipientTokenAccount: recipientTokenAccount,
          tokenProgram: TOKEN_PROGRAM_ID,
        })
        .rpc();
      
      console.log('Withdrawal successful!');
      console.log('Transaction signature:', tx);
      return tx;
    } catch (error) {
      console.error('Withdrawal failed:', error);
      throw error;
    }
  }
}

// Example usage
async function main() {
  const client = new PrivaxClient();
  
  // Example: Create a new token mint and initialize the protocol
  // This would be called only once during setup
  
  /*
  const connection = new Connection(RPC_URL, 'confirmed');
  const wallet = loadWallet();
  
  // Create token
  const token = await Token.createMint(
    connection,
    wallet,
    wallet.publicKey,
    null,
    9,
    TOKEN_PROGRAM_ID
  );
  
  // Initialize the protocol
  await client.initialize(
    token.publicKey,
    Keypair.generate().publicKey // Placeholder for verifier program
  );
  */
  
  console.log('Privax Protocol Client ready!');
  console.log('Use the PrivaxClient class to interact with the protocol.');
}

// Run the main function if this script is executed directly
if (require.main === module) {
  main().catch(err => {
    console.error(err);
    process.exit(1);
  });
} 